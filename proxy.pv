(*assumes private as protected by Solid-OIDC*)
free c: channel [private] . (* out client, in proxy  *)
free c2: channel [private] . (* in client, out proxy  *)
free d: channel [private] .  (* out proxy, in org  *)
free e: channel [private] .  (* in  proxy, out org  *)
free a: channel [private] .  (* out proxy, in affiliate  *)
free pub: channel .  (* public channel  *)

type name.

free OK: bitstring.
free notOK: bitstring.
free validName: name [private] . (* a client name which is authorized to perform operations*)
free invalidName: name [private] . (* a client name which is NOT authorized to perform any operation *)


event clientSendName . (* event emitted if client sends name and op *)
event clientReceiveResponse . (* event emitted after client receives a response  *)

event proxyNotOK . (* event emitted if organization responds NOT OK to proxy  *)
event proxyOK . (* event emitted if organization responds OK to proxy  *)

event orgAsked . (* event emitted when org receives a message to check a name  *)

event affReceivesMsg . (* event emitted if affiliate accepts org name of proxy  *)


(* Goal 1: When client sends a message to affiliate via the proxy, the org has to have seen the message before forwarding *)
query event(affReceivesMsg) ==> (event(proxyOK) ==> event(orgAsked)).

(* Goal 2: Whenever client sends a request, it will receive a response *)
query event(clientReceiveResponse) ==> event(clientSendName) . 

(* Goal 3: The affiliate will never get to known a client's name from the proxy regardless of whether the name is valid or invalid *)
query attacker(validName) .
query attacker(invalidName) .

(*===Client that wants to perform an operation op===*)
let client(clientname : name, op : bitstring) = 
  event clientSendName ;
  out(c, (clientname, op));
  in(c2, resp : bitstring);
  event clientReceiveResponse . 

(*===Proxy who has to forward operation op===*)
let proxy(orgName : name) =
  in(c, (xname : name , xop : bitstring)) ;
  out(d, (xname , xop )) ;
  in(e, resp: bitstring) ;
  if resp = OK then (event proxyOK; out(a, (orgName, xop)); in(a, aresp:bitstring); out(c2, aresp) ) else ( event proxyNotOK; out(c2, notOK)) .

(*===Organization to look up if client with name is allowed===*)
let organization(okName : name, okOp : bitstring) =
  in(d, (yname : name , yop : bitstring)) ;
  event orgAsked ;
  if yname = okName then (if yop = okOp then ( out(e,OK)) else out(e, notOK) ) else out(e, notOK) .

(*===Affiliate to whom the operation is fowarded to===*)
let affiliate(orgName: name, op: bitstring)  =
  in(a, (zname : name, zop : bitstring)) ;
  if zname = orgName then ( if zop = op then ( event affReceivesMsg ;  out(a,OK)) else out(a, notOK) ) else out(a, notOK) ;
  out(pub, zname) . (* publish received name to check if affiliate received secret client name*)

process
  new op: bitstring; (*the operation to be applied to the affiliate*)
  new orgName: name; (* the organization's name aka the name the proxy uses*)
  (* one client is initalized with a valid name and the operation, one client with an invalid name, proxy know the organization name, organization knows which client is allowed to perform what operation, the affiliation knows the organization  *)
  !(client(invalidName, op) | client(validName, op) | proxy(orgName) | organization(validName , op) | affiliate(orgName, op))
